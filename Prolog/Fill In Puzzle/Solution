/* Written by Joshua Munro 993658

This program solves a fill-in puzzle. It is satisfied if Puzzle is a solveable
grid of words from Wordlist.

Approach

A fill-in puzzle is a word puzzle with a grid and a wordlist. The objective
is to fill in each word from the wordlist into the grid, where there may be
squares with no letters (represented here as a hash character). Unknown 
letters are represented as underscores (_) and pre-filled characters are
represented as themselves. The Puzzle itself is represented as a list of lists, 
with inner lists representing rows.

The program has two main steps. The first is to generate a list of
horizontal and vertical words, which are represented using Prolog's logical
variables. This means that letters in common between words will automatically 
be filled in while the puzzle is solved.

The second step is to solve the puzzle. It prioritises unknown words with the 
fewest possible fill-in words first and pivots on possible permutations from 
this. This minimises the total number of choices the program makes. It is O(n!) 
time in the worst case, but is efficient in puzzles solveable by humans in 
reasonable time and probably resembles O(n^2) average time.
*/

:- ensure_loaded(library(clpfd)).
:- ensure_loaded(library(pairs)).
:- ensure_loaded(library(apply)).

%% puzzle_solution is satisfied if Wordlist is a list of words that solve
%% Puzzle. It finds horizontal words, then vertical words, and then solves
%% these words with the Wordlist
puzzle_solution(Puzzle, Wordlist) :-
    select_words(Puzzle, Horizontal_Words),
    transpose(Puzzle,Transposed_Puzzle),
    select_words(Transposed_Puzzle,Vertical_Words),
    append(Horizontal_Words, Vertical_Words, All_Words),
    solve(All_Words, Wordlist).

%% solve(List1,List2) is true when List1 can be unified pairwise with List2
%% This solver first prioritises unknown words with the fewest possible
%% matches in the Wordlist. It pivots on this word and tests each word in
%% Wordlist that might match it. If the word matches it recurses through until
%% the remaining words are unsolveable or a solution is found. If a permutation
%% is not a solution, then it backtracks and retries from the last pivot point.
solve([],[]).
solve(Unknown_List,Wordlist) :-
    priority_order_sort(Unknown_List, Wordlist, Sorted),
    Sorted = [First|R1],
    member(Pivot, Wordlist), % Pivot point
    First = Pivot,
    select(Pivot, Wordlist, R2),
    solve(R1, R2).


%% priority_order_sort(List1,List2,List3) is true if List3 is a stable sorted
%% list of List1 in terms of how many times each element of List1 can be unified
%% in List2
priority_order_sort(Unknown_List, Wordlist, Values) :- 
    make_priority_list(Unknown_List, Wordlist, Keylist),
    keysort(Keylist, Sorted),
    pairs_values(Sorted,Values).


%% make_priority_list(List1,List2,List3) is true if List3 is a list of
%% key pairs of elements of List1 generated by make_priority
make_priority_list([],_,[]).
make_priority_list([First|Rest], Wordlist, Keylist) :-
    make_priority(First, Wordlist, Keypair),
    make_priority_list(Rest, Wordlist, Other),
    append([Keypair], Other, Keylist).

%% make_priority(List1, List2, Key - List1) is true if Key is the number of
%% times List1 can be unified with words in List2
make_priority(Word, Wordlist, Key - Word) :- 
    setof(Word, member(Word,Wordlist), Set),
    length(Set, Key).


%% select_words(List1,List2) is true if List2 is a list of all horizontal
%% words separated by # in List1 with words of length 1 removed.
select_words([],[]).    
select_words([Row|Rest], List) :-
    row_select(Row, Words),
    select_words(Rest, OWords),
    include(not_length_one, Words, ValidWords),
    append(ValidWords, OWords, List).

%% not_length_one(List) is true if List is not a list of length one.

not_length_one(List) :- List \= [_].

%% row_select(List1,List2) is true if List2 is a list of words in List1
%% with different words separated by #
row_select([],[]).
row_select([First|Rest], Words) :- First == '#', row_select(Rest,Words).
row_select([First|Rest], Words) :- 
    First \== '#',
    get_word([First|Rest], Word),
    append(Word, Remaining, [First|Rest]),
    row_select(Remaining,Other),
    append([Word],Other, Words).


%% get_word(List1,List2) is true if List2 is the longest continuous sublist of 
%% List1 starting from the first element of List1 and ending at the first hash
%% or end of line if there are no hashes.
get_word([],[]).
get_word([First|_], []) :- First == '#'.
get_word([First|Rest], Word) :- 
    First \== '#', 
    get_word(Rest, Other),
    append([First],Other,Word).

